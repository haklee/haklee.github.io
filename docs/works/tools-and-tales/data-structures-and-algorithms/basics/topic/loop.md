---
title: "반복문"
---

[:material-arrow-left-bold: 글 목록](../index.md){ .md-button }

## 반복문

반복문은 말 그대로 특정한 작업을 반복하여 시행할때 사용한다. while과 for를 사용하는 두 가지 스타일이 일반적이다.

    ``` txt
    // while
    while (조건):
        (조건이 참일 경우 실행할 코드)
    
    // for
    for((시작); (조건); (반복)):
        (조건이 참일 경우 실행할 코드)
    ```

구체적인 구현은 아래 각 언어 탭에서 자세히 살펴보도록 하겠다.

=== "python"

    ``` python
    """while문을 먼저 살펴보자.
    정수가 들어있는 리스트가 주어지고, 여기서 양수의 합이 100이 넘는지 판별하는 것이 목표다.
    판별한 결과는 `is_over`라는 변수에 bool값으로 저장하겠다.
    """
    l = [-1, 20, -44, -21, 52, 6]
    is_over = False

    # 합을 저장할 변수를 만들자.
    s = 0  # 처음에는 아무 숫자도 안 더한 상태이므로 0으로 초기화한다.

    # 리스트에 있는 아이템에 하나하나 접근할 것이다.
    # 인덱스를 0부터 시작해서 1씩 늘리는 방법을 쓰는 것이 무난하다.
    i = 0
    while i < len(l):  # i값이 리스트의 길이가 되면 멈춘다.
        # 예를 들어, 길이 5짜리 리스트의 마지막 인덱스는 4이므로,
        # i가 5가 되면 반복을 멈춰야 한다.
        
        if l[i] > 0:
            # 리스트 l의 i번째 인덱스에 해당하는 아이템이 양수인지 확인하고,
            # 양수일 경우에만 조건문 안으로 들어온다.
            s += l[i]
        
        i += 1  # i값을 1 늘려준다.
        # 이렇게 해야 반복문 맨 위로 돌아갔을때 리스트의 다음 아이템을 처리할 수 있다.
    
    # while문을 탈출하면 이 줄이 실행된다.
    is_over = s > 100  # s가 100이 넘으면 is_over가 true가 된다.


    """만약에 앞선 while문 안에서 i에 1을 더하지 않는 시행을 하면 어떻게 될까?
    - i는 0으로 시작한다.
    - 반복문을 한 차례 돌면서 l[0]을 처리하고 나서 다시 while문 맨 위로 돌아간다.
    - i가 len(l)보다 작은지 확인한다.
    - 그런데 i는 그대로 0이다.
    - l[0]을 다시 처리한다. 그리고 다시 while문 맨 위로 돌아간다.
    - i가 len(l)보다 작은지 확인한다.
    - 그런데 i는 그대로 0이다.
    - ...
    이 코드는 while문 안에 갇혀서 계속 돈다. 이를 무한루프에 빠졌다고 표현하며,
    실제 코드에 이런 무한루프가 있으면 프로그램이 멈출 수 있으니 주의해야 한다!
    """

    s = 0
    i = 0
    while i < len(l):
        if l[i] > 0:
            s += l[i]
        
        # i += 1  # 이 줄이 주석처리되면 실행되지 않는다. 즉, 무한루프에 빠진다.

    """while문을 시작할때 조건을 확인하고 while문에서 빠져나오는 방법 외에, while문
    중간에 `break`문을 써서 빠져나오는 것도 가능하다.
    """

    s = 0
    i = 0
    while i < len(l):
        if l[i] > 0:
            s += l[i]
        if s > 100:
            break  # 중간에 s가 100을 넘을 경우 루프를 깨고 빠져나온다.
        i += 1
    
    """for문은 주어진 리스트를 순회하는 식으로 동작한다는 점에서 무한루프에 빠질 수
    있는 while문에 비해 안전하다.

    그리고 파이썬에서의 for문은 앞서 설명한 일반적인 for문 구조와 많이 다르다. 코드를
    보면서 설명하겠다.
    """

    s = 0
    # i = 0  # 이 줄이 없어졌다.
    for i in range(len(l)):  # while문의 코드와 이 줄이 달라졌다.
        if l[i] > 0:
            s += l[i]
        if s > 100:
            break
        # i += 1  # 그리고 이 줄이 없어졌다.

    # for문은 어떤 '순회 가능한 객체'가 주어졌을때 이 안에 있는 값에 하나씩 접근해서
    # 반복문 안에 있는 코드를 실행한다.

    for i in [1, 3, 5, 7]:
        # [1, 3, 5, 7]이라는 리스트에 있는 아이템에 순차적으로 접근해서 i에 넣는다.
        # 먼저 1, 그 다음 3, 그 다음 5, 그 다음 7을 i에 넣고, 리스트에 있는 모든
        # 아이템들을 다 처리했으면 for문이 자동으로 종료된다.
        pass  # 반복문 안에서 아무 것도 안 하고 싶으면 pass를 쓰면 된다.

    # range()는 숫자 시퀀스를 만들어준다.
    # 지금은 range(5)가 [0, 1, 2, 3, 4]와 같이, 0부터 시작하는 n개의 정수를 차례대로
    # 들고 있다는 것만 알아도 괜찮다.

    s = 0

    for i in range(len(l)):  # 0부터 시작하는 리스트 길이 만큼의 정수들에 대하여
        if l[i] > 0:
            s += l[i]  # l[i]가 양수일 경우 s에 l[i]를 더한다.
        if s > 100:
            break
    
    is_over = s > 100  # 그리고 s가 100보다 큰지 판별해서 is_over에 넣는다.

    """위의 for문 설명대로라면, 굳이 리스트에 인덱스로 접근하지 않아도 괜찮다는 것을
    알 수 있다. 이를 반영하여 다음과 같이 좀 더 직관적인 코드를 작성할 수 있다.
    """

    s = 0

    for i in l:  # 그냥 l에 있는 아이템에 직접 접근하는 것이 더 편해보인다.
        if i > 0:
            s += i  # 원래는 l[i]로 아이템에 접근했는데, 이제는 아이템이 i에 직접 들어가있다.
        if s > 100:
            break
    
    is_over = s > 100
    ```

=== "javascript"

    ``` js
    // WIP
    ```

=== "C#"

    ``` cs
    // WIP
    ```

=== "C++"

    ``` cpp
    // WIP
    ```

[:material-arrow-left-bold: 글 목록](../index.md){ .md-button }
