---
title: "Skill Tree for Architects Interested in Learning Development - Introduction"
---

[:material-arrow-left-bold: Back to post list](../index.md){ .md-button }

`2024. 08. 03.`

The main points I wanted to make in my previous posts about the difficulty of using for-loops in Grasshopper[(link)](./0727.md), the desire to work with developers who have both implementation and explanation skills[(link)](./0729.md), and architects not considering reproducibility enough[(link)](./0731.md), can be summarized as follows: "If you're an architect interested in learning development, stop relying solely on Grasshopper and start studying a programming language. Also, learn how developers manage their work and collaborate."

To put it even more concisely, it's about picking a programming language to study and learning how to use git. So, what exactly should we study, how deeply should we study it, and how should we approach this learning? As an architecture student who has been self-studying development for quite some time and experiencing it in the field, I've had many opportunities to ponder these questions. In the process, I've come up with my own answers and thought about a skill tree, the early stages of which can be summarized as follows:

- If you've never worked with a programming language before, start with either Python or C#. This is a common choice based on the programs architects typically use. If you're interested in web services, JavaScript could also be an option.
- Once you've chosen a language, study it until you can solve Bronze-level problems (based on solved.ac) on BOJ (Baekjoon Online Judge).
- Git will likely be an unfamiliar tool for most architects. At first, it's sufficient to approach it as a more sophisticated way of managing files like "final.psd, realfinal.psd, realrealfinal.psd, realrealfinal-2.psd, ..."
- Based on this perspective, study git until you can manage your own BOJ problem solutions on GitHub.

Of course, there are many resources available online for studying both programming languages and git, but the abundance of information might actually be confusing for beginners who don't know what to focus on. This issue could be resolved either by my carefully selecting and sharing suitable study materials, or by creating the materials myself.

The next challenge to address is finding practice materials to ensure that the learning doesn't end after a single study session. An initial solution to this is solving algorithm problems, as mentioned earlier. About two months ago, solved.ac introduced a 'marathon' feature that selects eight problems each week based on the difficulty of problems user solved so far, which I think is quite useful as practice material.

If implementing something more familiar to architects seems more interesting than solving algorithm problems, you could try implementing Grasshopper components or Dynamo nodes in code one by one. One issue, however, is that while the implementation difficulty of Grasshopper components varies greatly, there's no organized resource suggesting which components to start with. This means it might not be the best practice material until you've become proficient enough in development to gauge the difficulty levels yourself. Just as solved.ac was created to assign difficulty levels to problems on BOJ, I once thought it might be interesting to create a system where architects could share their code and rate the difficulty levels. I'll explain more about this in another post later.

[:material-arrow-left-bold: Back to post list](../index.md){ .md-button }